#!/usr/bin/env bash

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lct_usage() {
  printf "lct - Local configuration tool\n\n"

  printf "%s\n" "Usage:"
  printf "  lct COMMAND\n"
  printf "  lct [COMMAND] --help | -h\n"
  printf "  lct --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Manage lct libraries\n" "lib        "
  printf "  %s   Manage local environment variables\n" "env        "
  printf "  %s   Bootstrap your local configuration\n" "bootstrap  "
  printf "  %s   Generate bash completions\n" "completions"
  printf "  %s   Open your lct config file in your $EDITOR\n" "config     "
  printf "  %s   Setup lct in your shell\n" "setup      "
  printf "  %s   Gather local configuration files\n" "gather     "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lct_lib_usage() {
  printf "lct lib - Manage lct libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib COMMAND\n"
  printf "  lct lib [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Install libraries\n" "install"
  printf "  %s   Add a library to lct\n" "add    "
  printf "  %s   Remove a library from lct\n" "remove "
  printf "  %s   Dump the current lct libraries to your Brewfile\n" "dump   "
  printf "  %s   List all lct libraries\n" "list   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct lib add mylib\n"
    echo

  fi
}

# :command.usage
lct_lib_install_usage() {
  printf "lct lib install - Install libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib install\n"
  printf "  lct lib install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_lib_add_usage() {
  printf "lct lib add - Add a library to lct\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib add LIBRARY\n"
  printf "  lct lib add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LIBRARY"
    printf "    Name of the library to add\n"
    echo

  fi
}

# :command.usage
lct_lib_remove_usage() {
  printf "lct lib remove - Remove a library from lct\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib remove LIBRARY\n"
  printf "  lct lib remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LIBRARY"
    printf "    Name of the library to remove\n"
    echo

  fi
}

# :command.usage
lct_lib_dump_usage() {
  printf "lct lib dump - Dump the current lct libraries to your Brewfile\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib dump\n"
  printf "  lct lib dump --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_lib_list_usage() {
  printf "lct lib list - List all lct libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib list [OPTIONS]\n"
  printf "  lct lib list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--type, -t TYPE"
    printf "    Filter libraries by type\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_env_usage() {
  printf "lct env - Manage local environment variables\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct env COMMAND\n"
  printf "  lct env [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Set a configuration variable\n" "set  "
  printf "  %s   Unset a configuration variable\n" "unset"
  printf "  %s   List all configuration variables\n" "list "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct env set API_KEY 123\n"
    printf "  lct env get API_KEY\n"
    printf "  lct env unset API_KEY\n"
    printf "  lct env list\n"
    echo

  fi
}

# :command.usage
lct_env_set_usage() {
  printf "lct env set - Set a configuration variable\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env set KEY VALUE\n"
  printf "  lct env set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Configuration key\n"
    echo

    # :argument.usage
    printf "  %s\n" "VALUE"
    printf "    Configuration value\n"
    echo

  fi
}

# :command.usage
lct_env_unset_usage() {
  printf "lct env unset - Unset a configuration variable\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env unset KEY\n"
  printf "  lct env unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Configuration key\n"
    echo

  fi
}

# :command.usage
lct_env_list_usage() {
  printf "lct env list - List all configuration variables\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env list [OPTIONS]\n"
  printf "  lct env list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--key, -k KEY"
    printf "    Output in export format for shell sourcing\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_bootstrap_usage() {
  printf "lct bootstrap - Bootstrap your local configuration\n\n"
  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct bootstrap [OPTIONS]\n"
  printf "  lct bootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config, -c CONFIG"
    printf "    Config version to bootstrap\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct bootstrap -c 26.01.20\n"
    echo

  fi
}

# :command.usage
lct_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "lct completions\n\n"
    printf "  Generate bash completions\n  Usage: eval \"\$(lct completions)\"\n\n"
  else
    printf "lct completions - Generate bash completions\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  lct completions\n"
  printf "  lct completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_config_usage() {
  printf "lct config - Open your lct config file in your $EDITOR\n\n"

  printf "%s\n" "Usage:"
  printf "  lct config\n"
  printf "  lct config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct config\n"
    echo

  fi
}

# :command.usage
lct_setup_usage() {
  printf "lct setup - Setup lct in your shell\n\n"

  printf "%s\n" "Usage:"
  printf "  lct setup\n"
  printf "  lct setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  eval \"$(lct setup)\"\n"
    echo

  fi
}

# :command.usage
lct_gather_usage() {
  printf "lct gather - Gather local configuration files\n\n"
  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct gather [OPTIONS]\n"
  printf "  lct gather --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    overwrite existing version if conflicting\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct gather\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/send_completions.sh
send_completions() {
  echo $'# lct completion                                           -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/bashly-framework/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_lct_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  # words the user already typed (excluding the command itself)'
  echo $'  local used=()'
  echo $'  if ((COMP_CWORD > 1)); then'
  echo $'    used=("${COMP_WORDS[@]:1:$((COMP_CWORD - 1))}")'
  echo $'  fi'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    # Completing an option: offer everything (including options)'
  echo $'    echo "$words"'
  echo $''
  echo $'  else'
  echo $'    # Completing a non-option: offer only non-options,'
  echo $'    # and don\'t re-offer ones already used earlier in the line.'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" == "-" ]] && continue'
  echo $''
  echo $'      local seen=0'
  echo $'      for u in "${used[@]}"; do'
  echo $'        if [[ "$u" == "$word" ]]; then'
  echo $'          seen=1'
  echo $'          break'
  echo $'        fi'
  echo $'      done'
  echo $'      ((!seen)) && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_lct_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=()'
  echo $'  if ((COMP_CWORD > 0)); then'
  echo $'    compwords=("${COMP_WORDS[@]:1:$((COMP_CWORD - 1))}")'
  echo $'  fi'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  COMPREPLY=()'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'bootstrap\'*\'--config\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls -d $HOME/code/personal/local/config_versions/*/ | xargs -n 1 basename | tr \'\n\' \' \' 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*\'--type\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "cargo cask flatpak formula go mas tap vscode")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*\'--key\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*\'--key\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'bootstrap\'*\'-c\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls -d $HOME/code/personal/local/config_versions/*/ | xargs -n 1 basename | tr \'\n\' \' \' 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib install\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*\'-k\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*\'-t\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "cargo cask flatpak formula go mas tap vscode")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib remove\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*\'--config\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls -d $HOME/code/personal/local/config_versions/*/ | xargs -n 1 basename | tr \'\n\' \' \' 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*\'-k\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'bootstrap\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--config --help -c -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env unset\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --key -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --type -h -t")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib dump\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e unset\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env set\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib add\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'config\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --key -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'gather\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--force --help -f -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e set\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'setup\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*\'-c\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls -d $HOME/code/personal/local/config_versions/*/ | xargs -n 1 basename | tr \'\n\' \' \' 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h list set unset")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h add dump install list remove")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'g\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--force --help -f -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--config --help -c -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h list set unset")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --version -h -v b bootstrap completions config e env g gather lib setup")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'  complete -F _lct_completions lct'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/send_environment.sh
send_environment() {
  echo "$(yq -r 'to_entries | .[] | "export \(.key)=\((.value|tostring)|@sh)"' "$LCT_ENV_FILE")"
}

# :command.command_functions

# :command.function
lct_lib_install_command() {

  # src/commands/lib/install.sh
  brew bundle --file=$LCT_BREW_FILE
  mise install

}

# :command.function
lct_lib_add_command() {

  # src/commands/lib/add.sh
  libname=${args[library]}

  brew bundle add $libname --file=$LCT_BREW_FILE

}

# :command.function
lct_lib_remove_command() {

  # src/commands/lib/remove.sh
  libname=${args[library]}

  brew bundle remove $libname --file=$LCT_BREW_FILE

}

# :command.function
lct_lib_dump_command() {

  # src/commands/lib/dump.sh
  brew bundle dump --file=$LCT_BREW_FILE --force --describe

}

# :command.function
lct_lib_list_command() {

  # src/commands/lib/list.sh
  lib_type=${args[--type]:-"all"}
  eval $(echo "brew bundle list --file=$LCT_BREW_FILE --${lib_type}")

}

# :command.function
lct_env_set_command() {

  # src/commands/env/set.sh
  env_key=${args[key]}
  env_value=${args[value]}

  yq -i ".${env_key} = \"${env_value}\"" $LCT_ENV_FILE
  eval "$(send_environment)"

}

# :command.function
lct_env_unset_command() {

  # src/commands/env/unset.sh
  env_key=${args[key]}
  yq -i "del(.${env_key})" $LCT_ENV_FILE
  unset -v $env_key
  eval "$(send_environment)"

}

# :command.function
lct_env_list_command() {

  # src/commands/env/list.sh
  env_key=${args[--key]:-""}
  if [ -z "$env_key" ]; then
    yq -o=shell $LCT_ENV_FILE
  else
    echo "$env_key=$(yq ".$env_key" $LCT_ENV_FILE)"
  fi

}

# :command.function
lct_bootstrap_command() {

  # src/commands/bootstrap.sh
  CONFIG_VERSION=${args[--config]:-""}
  TMP_DIR=$(mktemp -d)

  trap 'rm -rf "$TMP_DIR"' EXIT

  if [[ ! -z $CONFIG_VERSION ]]; then
    LATEST_LCT_VERSION="$CONFIG_VERSION"
  fi

  LATEST_LCT_VERSION_DIR="$TMP_DIR/$LATEST_LCT_VERSION"

  echo "Starting Bootstrap Process"

  echo "Decompressing latest configuration version: $LATEST_LCT_VERSION"
  tar -xJf "$LCT_VERSIONS_DIR/$LATEST_LCT_VERSION.tar.xz" -C "$TMP_DIR"
  echo "✅ Decompression complete"

  echo "Installing homebrew dependencies"
  brew bundle --file "$LCT_BREW_FILE"
  echo "✅ homebrew dependencies succesfully installed"

  if [ -d "$SOFTWARE_DIR" ]; then
    echo " $SOFTWARE_DIR already exists"
  else
    echo " Creating $SOFTWARE_DIR"
    mkdir -p $SOFTWARE_DIR
  fi

  echo "Applying library configs"

  for lib in "${CONFIGS[@]}"; do
    if [ -d "$CONFIG_DIR/$lib" ]; then
      echo "$lib config already exists"
    else
      echo "Applying $lib config"
      cp -r "$LATEST_LCT_VERSION_DIR/$lib" "$CONFIG_DIR/"
    fi
  done

  echo "✅ Configs successfully copied"

  # INSTALL OH-MY-ZSH
  if [ -d "$HOME/.oh-my-zsh" ]; then
    echo "✅ oh-my-zsh already installed"
  else
    echo "installing oh-my-zsh"
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/master/tools/insall.sh)"
    echo "✅ oh-my-zsh succesfully installed"
  fi

  # INSTALL ZSH ITEMS

  if [ -d "${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions" ]; then
    echo "✅ zsh-completions already installed"
  else
    echo "installing zsh-completions"
    git clone https://github.com/zsh-users/zsh-completions.git ${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions
    echo "✅ zsh-completions succesfully installed"
  fi

  if [ -d "${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-syntax-highlighting" ]; then
    echo "✅ zsh-syntax-highlighting already installed"
  else
    echo "installing zsh-syntax-highlighting"
    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
    echo "✅ zsh-syntax-highlighting successfully installed"
  fi

  if [ -d "${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-autosuggestions" ]; then
    echo "✅ zsh-autosuggestions already installed"
  else
    echo "installing zsh-autosuggestions"
    git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
    echo "✅ zsh-autosuggestions successfully installed"
  fi

  # INSTALL POWERLEVEL10K
  if [ -d "${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/themes/powerlevel10k" ]; then
    echo "✅ powerlevel10k already installed"
  else
    echo "installing powerlevel10k"
    git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"
    echo "✅ powerlevel10k succesfully installed"
  fi

  # INSTALL MISE
  if ! command -v mise &>/dev/null; then
    echo "installing mise"
    curl https://mise.run | sh
    echo 'eval "$(~/.local/bin/mise activate zsh)"' >>~/.zshrc
    mise install
    echo "✅ mise succesfully installed"
  else
    echo "✅ mise already installed"
  fi

  # INSTALL alacritty
  if [ -d "/Applications/Alacritty.app" ]; then
    echo "✅ alacritty already installed"
  else
    echo "installing alacritty"
    git clone git@github.com:alacritty/alacritty.git $SOFTWARE_DIR/alacritty
    cd $SOFTWARE_DIR/alacritty
    make app
    cp -r target/release/osx/Alacritty.app /Applications/
    ln -s /Applications/Alacritty.app/Contents/MacOS/alacritty /usr/local/bin/alacritty
    sudo tic -xe alacritty,alacritty-direct extra/alacritty.info
    cp extra/completions/_alacritty ~/.zsh_functions/_alacritty
    echo "✅ alacritty succesfully \installed"
  fi

  # INSTALL jrnl
  if ! command -v jrnl &>/dev/null; then
    echo "installing jrnl"
    pip install jrnl
    echo "✅ jrnl succesfully installed"
  else
    echo "✅ jrnl already installed"
  fi

  # INSTALL lazyvim
  if [ -f "$CONFIG_DIR/nvim/lazyvim.json" ]; then
    echo "✅ LazyVim already installed"
  else
    echo "Installing LavyVim"
    echo "Applying LazyVim config"
    echo "Backing up existing nvim config if it exists"
    if [ -d $CONFIG_DIR/nvim ]; then
      mv $CONFIG_DIR/nvim $CONFIG_DIR/nvim.bak
    fi

    if [ -d $SHARE_DIR/nvim ]; then
      mv $SHARE_DIR/nvim $SHARE_DIR/nvim.bak
    fi

    if [ -d "$STATE_DIR/nvim" ]; then
      mv "$STATE_DIR/nvim" "$STATE_DIR/nvim.bak"
    fi

    if [ -d "$CACHE_DIR/nvim" ]; then
      mv "$CACHE_DIR/nvim" "$CACHE_DIR/nvim.bak"
    fi

    git clone https://github.com/LazyVim/starter ~/.config/nvim
    rmz -f ~/.config/nvim/.git

    cp -r "$LATEST_LCT_VERSION_DIR/lazyvim/lazyvim.json" "$CONFIG_DIR/nvim/lazyvim.json"
    cp -r "$LATEST_LCT_VERSION_DIR/lazyvim/lua" "$CONFIG_DIR/nvim/lua"
  fi

  echo "✅ Bootstrap complete"
  echo "Feel free to add  the following to your zshrc file"
  echo 'eval "$(lct setup)"'

}

# :command.function
lct_completions_command() {

  # src/commands/completions.sh
  send_completions

}

# :command.function
lct_config_command() {

  # src/commands/config.sh
  eval "$EDITOR $LCT_CONFIG_FILE"

}

# :command.function
lct_setup_command() {

  # src/commands/setup.sh
  echo $"autoload -Uz +X bashcompinit && bashcompinit"
  printf '\n\n'
  send_environment
  printf '\n\n'
  send_completions
  printf '\n\n'
  zoxide init zsh
  printf '\n\n'
  zellij setup --generate-auto-start zsh

}

# :command.function
lct_gather_command() {

  # src/commands/gather.sh
  latest_version=$(yq '.latest' "$LCT_VERSIONS_FILE")
  this_version=$(date +%Y.%m.%d)

  FORCE=${args[--force]:-0}
  VERSION_DIR="$LCT_VERSIONS_DIR/$this_version"
  LCT_FILES=("$LCT_BREW_FILE")

  if [ "$this_version" == "$latest_version" ]; then
    if [[ $FORCE -eq 1 ]]; then
      echo "⚠ Forcing config gather despite being up to date"
    else
      echo "✅ Configs are already up to date"
      exit 0
    fi
  fi

  echo "Gathering configs for new version: $this_version"
  mkdir -p "$VERSION_DIR"
  mkdir -p "$VERSION_DIR/config"
  mkdir -p "$VERSION_DIR/dotfiles"
  mkdir -p "$VERSION_DIR/lazyvim"

  echo "Gathering LCT files"
  for file in "${LCT_FILES[@]}"; do
    echo "Copying $(basename "$file")"
    cp -r "$file" "$VERSION_DIR/"
  done

  echo "Gather library configs"

  for lib in "${CONFIGS[@]}"; do
    echo "Copying $lib config"
    cp -r "$CONFIG_DIR/$lib" "$VERSION_DIR/config/"
  done

  echo "✅ Configs successfully gathered"

  echo "Gathering dotfiles"

  for file in "${DOTFILES[@]}"; do
    echo "Copying $file"
    cp -r "$HOME/$file" "$VERSION_DIR/dotfiles/"
  done

  echo "✅ Dotfiles successfully gathered"

  echo "Gathering other files"
  for key in "${!OTHERFILES[@]}"; do
    src_file="$HOME/${OTHERFILES[$key]}"
    dest_file="$VERSION_DIR/$key"
    dest_dir=$(dirname "$dest_file")
    echo "Copying $src_file to $dest_file"
    mkdir -p "$dest_dir"
    cp -r "$src_file" "$dest_file"
  done

  echo "✅ Other files successfully gathered"

  echo "Compressing gathered configuration"
  tar -cJf "$LCT_VERSIONS_DIR/$this_version.tar.xz" -C "$LCT_VERSIONS_DIR" "$this_version"
  rm -rf "$VERSION_DIR"
  echo "✅ Successfully compressed configuration"

  # Update latest version in lct.yaml
  yq -i ".latest = \"$this_version\"" "$LCT_VERSIONS_FILE"

  git -C "$LCT_VERSIONS_DIR" add .
  git -C "$LCT_VERSIONS_DIR" commit -m "Gather configs for version $this_version" || echo "No changes to commit"
  git -C "$LCT_VERSIONS_DIR" push origin main || echo "No remote repository configured, skipping push"
  echo "✅ Config gather for version $this_version completed successfully"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lct_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    lib)
      action="lib"
      shift
      lct_lib_parse_requirements "$@"
      shift $#
      ;;

    env | e)
      action="env"
      shift
      lct_env_parse_requirements "$@"
      shift $#
      ;;

    bootstrap | b)
      action="bootstrap"
      shift
      lct_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      lct_completions_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      lct_config_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      lct_setup_parse_requirements "$@"
      shift $#
      ;;

    gather | g)
      action="gather"
      shift
      lct_gather_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    install)
      action="install"
      shift
      lct_lib_install_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      lct_lib_add_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      lct_lib_remove_parse_requirements "$@"
      shift $#
      ;;

    dump)
      action="dump"
      shift
      lct_lib_dump_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      lct_lib_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_lib_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_install_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_add_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['library']+x} ]]; then
          args['library']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['library']+x} ]]; then
    printf "missing required argument: LIBRARY\nusage: lct lib add LIBRARY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_lib_remove_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['library']+x} ]]; then
          args['library']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['library']+x} ]]; then
    printf "missing required argument: LIBRARY\nusage: lct lib remove LIBRARY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_lib_dump_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_dump_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib dump"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --type | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--type']="$2"
          shift
          shift
        else
          printf "%s\n" "--type requires an argument: --type, -t TYPE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_env_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      lct_env_set_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      lct_env_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      lct_env_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_env_set_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['key']+x} ]]; then
          args['key']=$1
          shift
        # :argument.case
        elif [[ -z ${args['value']+x} ]]; then
          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: lct env set KEY VALUE\n" >&2

    exit 1
  fi

  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: lct env set KEY VALUE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_env_unset_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['key']+x} ]]; then
          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: lct env unset KEY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_env_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --key | -k)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key, -k KEY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_bootstrap_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_completions_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_config_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_setup_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_gather_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_gather_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gather"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.2.0"
  set -Eeuo pipefail

  # src/initialize.sh
  # Function to handle errors
  error_handler() {
    local exit_code=$? # Capture the exit code of the failed command
    echo "❌ ERROR: Command failed with exit code $exit_code on line $LINENO" >&2
    echo "❌ Failing command: $BASH_COMMAND" >&2
    echo "❌ Local bootstrap failed"
    exit $exit_code # Exit the script with the original error code
  }

  # Expects:
  #   REMOTE_CONFIG_REPO   e.g. https://github.com/org/repo.git  (or git@github.com:org/repo.git)
  #   LCT_VERSIONS_DIR     path to an existing git working tree
  set_origin_remote() {
    : "${REMOTE_CONFIG_REPO:?REMOTE_CONFIG_REPO is required}"
    : "${LCT_VERSIONS_DIR:?LCT_VERSIONS_DIR is required}"

    if [[ ! -d "$LCT_VERSIONS_DIR/.git" ]]; then
      echo "Not a git repo: $LCT_VERSIONS_DIR" >&2
      return 1
    fi

    local current
    current="$(git -C "$LCT_VERSIONS_DIR" remote get-url origin 2>/dev/null || true)"

    if [[ -z "$current" ]]; then
      git -C "$LCT_VERSIONS_DIR" remote add origin "$REMOTE_CONFIG_REPO" &>/dev/null
    elif [[ "$current" != "$REMOTE_CONFIG_REPO" ]]; then
      git -C "$LCT_VERSIONS_DIR" remote set-url origin "$REMOTE_CONFIG_REPO" &>/dev/null
    fi
  }

  detect_directories() {
    if [ -z "${SOFTWARE_DIR+x}" ]; then
      SOFTWARE_DIR="$HOME/software"
    fi

    if [ -z "${CONFIG_DIR+x}" ]; then
      CONFIG_DIR="$HOME/.config"
    fi

    if [ -z "${SHARE_DIR+x}" ]; then
      SHARE_DIR="$HOME/.local/share"
    fi

    if [ -z "${STATE_DIR+x}" ]; then
      STATE_DIR="$HOME/.local/state"
    fi

    if [ -z "${CACHE_DIR+x}" ]; then
      CACHE_DIR="$HOME/.cache"
    fi

    LCT_SHARE_DIR="${SHARE_DIR}/lct"
    LCT_CONFIG_DIR="${CONFIG_DIR}/lct"
    LCT_ENV_FILE="${LCT_SHARE_DIR}/env.yaml"
    LCT_CONFIG_FILE="${LCT_CONFIG_DIR}/config.yaml"
    LCT_VERSIONS_DIR="${LCT_SHARE_DIR}/config_versions"
    LCT_VERSIONS_FILE="${LCT_VERSIONS_DIR}/lct.yaml"
    LCT_BREW_FILE="${LCT_SHARE_DIR}/Brewfile"
  }

  setup_directories() {
    detect_directories

    [[ -d "${LCT_SHARE_DIR}" ]] || mkdir -p "${LCT_SHARE_DIR}"
    [[ -d "${LCT_CONFIG_DIR}" ]] || mkdir -p "${LCT_CONFIG_DIR}"
    [[ -d "${LCT_VERSIONS_DIR}" ]] || mkdir -p "${LCT_VERSIONS_DIR}"
    [[ -f "${LCT_ENV_FILE}" ]] || touch "${LCT_ENV_FILE}"
    [[ -f "${LCT_CONFIG_FILE}" ]] || touch "${LCT_CONFIG_FILE}"
    [[ -f "${LCT_VERSIONS_FILE}" ]] || touch "${LCT_VERSIONS_FILE}"
    [[ -d "$LCT_VERSIONS_DIR/.git" ]] || git init "$LCT_VERSIONS_DIR"
    [[ -f "${LCT_BREW_FILE}" ]] || touch "${LCT_BREW_FILE}"
  }

  load_configuration() {
    # Load LCT configuration
    if [[ -f "${LCT_CONFIG_FILE}" ]]; then
      REMOTE_CONFIG_REPO=$(yq '.remote' ${LCT_CONFIG_FILE})
      CONFIGS=($(yq -o=csv '.configs[]' ${LCT_CONFIG_FILE}))
      DOTFILES=($(yq -o=csv '.dotfiles[]' ${LCT_CONFIG_FILE}))
      declare -gA OTHERFILES
      eval "OTHERFILES=($(yq -r '.other | to_entries | .[] | "[\(.key)]=\"\(.value)\""' ~/.config/lct/config.yaml | paste -sd' ' -))"
    fi
  }

  load_env() {
    # Load LCT environment variables
    if [[ -f "${LCT_ENV_FILE}" ]]; then
      eval "$(yq -o=shell '.' ${LCT_ENV_FILE})"
    fi

    if [ -z "${LATEST_LCT_VERSION+x}" ]; then
      LATEST_LCT_VERSION=$(yq '.latest' "$LCT_VERSIONS_FILE")
      LATEST_LCT_VERSION_DIR="$LCT_VERSIONS_DIR/$LATEST_LCT_VERSION"
    fi

    if [ $REMOTE_CONFIG_REPO != "null" ]; then
      set_origin_remote
    fi
  }

  trap 'error_handler' ERR
  setup_directories
  load_configuration
  load_env

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "lib") lct_lib_command ;;
    "lib install") lct_lib_install_command ;;
    "lib add") lct_lib_add_command ;;
    "lib remove") lct_lib_remove_command ;;
    "lib dump") lct_lib_dump_command ;;
    "lib list") lct_lib_list_command ;;
    "env") lct_env_command ;;
    "env set") lct_env_set_command ;;
    "env unset") lct_env_unset_command ;;
    "env list") lct_env_list_command ;;
    "bootstrap") lct_bootstrap_command ;;
    "completions") lct_completions_command ;;
    "config") lct_config_command ;;
    "setup") lct_setup_command ;;
    "gather") lct_gather_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
