#!/usr/bin/env bash

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lct_usage() {
  printf "lct - Local configuration tool\n\n"

  printf "%s\n" "Usage:"
  printf "  lct COMMAND\n"
  printf "  lct [COMMAND] --help | -h\n"
  printf "  lct --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Manage lct libraries\n" "lib        "
  printf "  %s   Manage local environment variables\n" "env        "
  printf "  %s   Develop and manage lct plugins\n" "plugin     "
  printf "  %s   Bootstrap your local configuration\n" "bootstrap  "
  printf "  %s   Generate bash completions\n" "completions"
  printf "  %s   Open your config files in your $EDITOR\n" "config     "
  printf "  %s   Setup lct in your shell\n" "setup      "
  printf "  %s   Gather local configuration files\n" "gather     "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lct_lib_usage() {
  printf "lct lib - Manage lct libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib COMMAND\n"
  printf "  lct lib [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Install libraries\n" "install"
  printf "  %s   Add a library to lct\n" "add    "
  printf "  %s   Remove a library from lct\n" "remove "
  printf "  %s   Dump the current lct libraries to your Brewfile\n" "dump   "
  printf "  %s   List all lct libraries\n" "list   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct lib add mylib\n"
    echo

  fi
}

# :command.usage
lct_lib_install_usage() {
  printf "lct lib install - Install libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib install\n"
  printf "  lct lib install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_lib_add_usage() {
  printf "lct lib add - Add a library to lct\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib add LIBRARY\n"
  printf "  lct lib add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LIBRARY"
    printf "    Name of the library to add\n"
    echo

  fi
}

# :command.usage
lct_lib_remove_usage() {
  printf "lct lib remove - Remove a library from lct\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib remove LIBRARY\n"
  printf "  lct lib remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LIBRARY"
    printf "    Name of the library to remove\n"
    echo

  fi
}

# :command.usage
lct_lib_dump_usage() {
  printf "lct lib dump - Dump the current lct libraries to your Brewfile\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib dump\n"
  printf "  lct lib dump --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_lib_list_usage() {
  printf "lct lib list - List all lct libraries\n\n"

  printf "%s\n" "Usage:"
  printf "  lct lib list [OPTIONS]\n"
  printf "  lct lib list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--type, -t TYPE"
    printf "    Filter libraries by type\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_env_usage() {
  printf "lct env - Manage local environment variables\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct env COMMAND\n"
  printf "  lct env [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Set a configuration variable\n" "set  "
  printf "  %s   Unset a configuration variable\n" "unset"
  printf "  %s   List all configuration variables\n" "list "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct env set API_KEY 123\n"
    printf "  lct env get API_KEY\n"
    printf "  lct env unset API_KEY\n"
    printf "  lct env list\n"
    echo

  fi
}

# :command.usage
lct_env_set_usage() {
  printf "lct env set - Set a configuration variable\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env set KEY VALUE\n"
  printf "  lct env set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Configuration key\n"
    echo

    # :argument.usage
    printf "  %s\n" "VALUE"
    printf "    Configuration value\n"
    echo

  fi
}

# :command.usage
lct_env_unset_usage() {
  printf "lct env unset - Unset a configuration variable\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env unset KEY\n"
  printf "  lct env unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Configuration key\n"
    echo

  fi
}

# :command.usage
lct_env_list_usage() {
  printf "lct env list - List all configuration variables\n\n"

  printf "%s\n" "Usage:"
  printf "  lct env list [OPTIONS]\n"
  printf "  lct env list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--key, -k KEY"
    printf "    Output in export format for shell sourcing\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_plugin_usage() {
  printf "lct plugin - Develop and manage lct plugins\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin COMMAND\n"
  printf "  lct plugin [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create a new lct plugin\n" "create "
  printf "  %s   Publish an lct plugin to the registry\n" "publish"
  printf "  %s   Install an lct plugin from the registry\n" "install"
  printf "  %s   Remove an installed lct plugin\n" "remove "
  printf "  %s   List all installed lct plugins\n" "list   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct plugin create myplugin\n"
    echo

  fi
}

# :command.usage
lct_plugin_create_usage() {
  printf "lct plugin create - Create a new lct plugin\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin create PLUGIN\n"
  printf "  lct plugin create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PLUGIN"
    printf "    Name of the plugin to create\n"
    echo

  fi
}

# :command.usage
lct_plugin_publish_usage() {
  printf "lct plugin publish - Publish an lct plugin to the registry\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin publish PLUGIN\n"
  printf "  lct plugin publish --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PLUGIN"
    printf "    Name of the plugin to publish\n"
    echo

  fi
}

# :command.usage
lct_plugin_install_usage() {
  printf "lct plugin install - Install an lct plugin from the registry\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin install PLUGIN\n"
  printf "  lct plugin install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PLUGIN"
    printf "    Name of the plugin to install\n"
    echo

  fi
}

# :command.usage
lct_plugin_remove_usage() {
  printf "lct plugin remove - Remove an installed lct plugin\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin remove PLUGIN\n"
  printf "  lct plugin remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PLUGIN"
    printf "    Name of the plugin to remove\n"
    echo

  fi
}

# :command.usage
lct_plugin_list_usage() {
  printf "lct plugin list - List all installed lct plugins\n\n"

  printf "%s\n" "Usage:"
  printf "  lct plugin list\n"
  printf "  lct plugin list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_bootstrap_usage() {
  printf "lct bootstrap - Bootstrap your local configuration\n\n"
  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct bootstrap [OPTIONS]\n"
  printf "  lct bootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config, -c CONFIG"
    printf "    Config version to bootstrap\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct bootstrap\n"
    printf "  lct bootstrap -c 26.01.20\n"
    echo

  fi
}

# :command.usage
lct_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "lct completions\n\n"
    printf "  Generate bash completions\n  Usage: eval \"\$(lct completions)\"\n\n"
  else
    printf "lct completions - Generate bash completions\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  lct completions\n"
  printf "  lct completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lct_config_usage() {
  printf "lct config - Open your config files in your $EDITOR\n\n"

  printf "%s\n" "Usage:"
  printf "  lct config [LIB_NAME]\n"
  printf "  lct config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LIB_NAME"
    printf "    Name of the config library to open\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct config\n"
    printf "  lct config alacritty\n"
    echo

  fi
}

# :command.usage
lct_setup_usage() {
  printf "lct setup - Setup lct in your shell\n\n"

  printf "%s\n" "Usage:"
  printf "  lct setup\n"
  printf "  lct setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  eval \"$(lct setup)\"\n"
    echo

  fi
}

# :command.usage
lct_gather_usage() {
  printf "lct gather - Gather local configuration files\n\n"
  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lct gather [OPTIONS]\n"
  printf "  lct gather --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    overwrite existing version if conflicting\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lct gather\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/progressbar.sh
#!/bin/bash
progressbar() {

  getColor() {
    case "$1" in
    black) color="0;30m" ;;
    red) color="1;31m" ;;
    green) color="1;32m" ;;
    blue) color="1;34m" ;;
    brown) color="0;33m" ;;
    yellow) color="1;33m" ;;
    white) color="1;37m" ;;
    esac
    echo "\033[$color"
  }

  printHelp() {
    echo
    echo 'usage: progress-bar [VALUE], VALUE percentage value, e.g. 10%, 50%, 100%, 110%'
    echo
    echo '  -h help'
    echo
    echo '  -l long output - allow more than 100%'
    echo '  -s [SIZE], SIZE number of ■ showed when value is 100 (default: 10)'
    echo '  -w [CHARACTER], CHARACTER characted that is being shown as progress bar tile (default: ■)'
    echo '  -a append numeric value after progress bar'
    echo '  -c [COLOR] black|red|green|blue|brown|yellow|white'
  }

  # DEFAULT CONFIG PARAMETERS
  color=
  allow_more_than_max=false
  character=■
  granularity=10
  append_numeric_after_progressbar=false

  # PARSE ARGS
  while getopts 'als:c:w:h' OPT ${@:2}; do
    case "$OPT" in
    "l") allow_more_than_max=true ;;
    "s") granularity=$OPTARG ;;
    "w") character=$OPTARG ;;
    "c") color=$(getColor $OPTARG) ;;
    "a") append_numeric_after_progressbar=true ;;
    "h")
      printHelp
      exit 1
      ;;
    "?")
      printHelp >&2
      exit 1
      ;;

    esac
  done

  if [ -p /dev/stdin ]; then
    value=$(cat /dev/stdin | tr -d % | tr -d '\n')
  else
    value=$(echo $1 | tr -d %)
  fi

  let step_size=100/$granularity
  let num_of_progress_items=$value/$step_size

  if [ "$color" ]; then
    printf $color
  fi

  printf '|'
  for i in $(seq 0 $granularity); do
    [[ $i -le $num_of_progress_items ]] && printf "$character" || printf ' '
  done

  printf '|'

  if [ "$allow_more_than_max" = true ] && [ $num_of_progress_items -gt $granularity ]; then
    let num_of_excess_items=$num_of_progress_items-$granularity
    for i in $(seq 1 $num_of_excess_items); do
      printf $character
    done
  fi

  if $append_numeric_after_progressbar; then
    printf ' %d%%' $value
  fi

  eval "tput sgr0" # reset color
  echo
}

# src/lib/send_completions.sh
send_completions() {
  echo $'# lct completion                                           -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/bashly-framework/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_lct_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  # words the user already typed (excluding the command itself)'
  echo $'  local used=()'
  echo $'  if ((COMP_CWORD > 1)); then'
  echo $'    used=("${COMP_WORDS[@]:1:$((COMP_CWORD - 1))}")'
  echo $'  fi'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    # Completing an option: offer everything (including options)'
  echo $'    echo "$words"'
  echo $''
  echo $'  else'
  echo $'    # Completing a non-option: offer only non-options,'
  echo $'    # and don\'t re-offer ones already used earlier in the line.'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" == "-" ]] && continue'
  echo $''
  echo $'      local seen=0'
  echo $'      for u in "${used[@]}"; do'
  echo $'        if [[ "$u" == "$word" ]]; then'
  echo $'          seen=1'
  echo $'          break'
  echo $'        fi'
  echo $'      done'
  echo $'      ((!seen)) && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_lct_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=()'
  echo $'  if ((COMP_CWORD > 0)); then'
  echo $'    compwords=("${COMP_WORDS[@]:1:$((COMP_CWORD - 1))}")'
  echo $'  fi'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  COMPREPLY=()'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'bootstrap\'*\'--config\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls $HOME/.local/share/lct/config_versions/ 2>/dev/null | grep -E \'^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.tar\.xz$\' | sed \'s/\.tar\.xz$//\' | tr \'\n\' \' \')")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*\'--type\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "cargo cask flatpak formula go mas tap vscode")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*\'--key\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin install\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin publish\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin remove\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin create\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*\'--key\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'bootstrap\'*\'-c\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls $HOME/.local/share/lct/config_versions/ 2>/dev/null | grep -E \'^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.tar\.xz$\' | sed \'s/\.tar\.xz$//\' | tr \'\n\' \' \')")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*\'-k\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*\'-t\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "cargo cask flatpak formula go mas tap vscode")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib install\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*\'--config\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls $HOME/.local/share/lct/config_versions/ 2>/dev/null | grep -E \'^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.tar\.xz$\' | sed \'s/\.tar\.xz$//\' | tr \'\n\' \' \')")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib remove\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*\'-k\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(yq \'keys | join(" ")\' $LCT_ENV_FILE 2> /dev/null)")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'bootstrap\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--config --help -c -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env unset\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --key -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --type -h -t")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib dump\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e unset\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env set\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib add\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'config\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls $HOME/.config/ 2> /dev/null | tr \'\n\' \' \') --help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'plugin\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h create install list publish remove")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --key -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'gather\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--force --help -f -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e set\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'setup\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*\'-c\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "$(ls $HOME/.local/share/lct/config_versions/ 2>/dev/null | grep -E \'^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.tar\.xz$\' | sed \'s/\.tar\.xz$//\' | tr \'\n\' \' \')")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'env\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h list set unset")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'lib\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h add dump install list remove")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'g\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--force --help -f -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'b\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--config --help -c -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help -h list set unset")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_lct_completions_filter "--help --version -h -v b bootstrap completions config e env g gather lib plugin setup")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'  complete -F _lct_completions lct'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/send_environment.sh
send_environment() {
  echo "$(yq -r 'to_entries | .[] | "export \(.key)=\((.value|tostring)|@sh)"' "$LCT_ENV_FILE")"
}

# :command.command_functions

# :command.function
lct_lib_install_command() {

  # src/commands/lib/install.sh
  brew bundle --file=$LCT_BREW_FILE
  mise install

}

# :command.function
lct_lib_add_command() {

  # src/commands/lib/add.sh
  libname=${args[library]}

  brew install $libname
  brew bundle add $libname --file=$LCT_BREW_FILE

}

# :command.function
lct_lib_remove_command() {

  # src/commands/lib/remove.sh
  libname=${args[library]}

  brew uninstall $libname
  brew bundle remove $libname --file=$LCT_BREW_FILE

}

# :command.function
lct_lib_dump_command() {

  # src/commands/lib/dump.sh
  brew bundle dump --file=$LCT_BREW_FILE --force --describe

}

# :command.function
lct_lib_list_command() {

  # src/commands/lib/list.sh
  lib_type=${args[--type]:-"all"}
  eval $(echo "brew bundle list --file=$LCT_BREW_FILE --${lib_type}")

}

# :command.function
lct_env_set_command() {

  # src/commands/env/set.sh
  env_key=${args[key]}
  env_value=${args[value]}

  yq -i ".${env_key} = \"${env_value}\"" $LCT_ENV_FILE
  eval "$(send_environment)"

}

# :command.function
lct_env_unset_command() {

  # src/commands/env/unset.sh
  env_key=${args[key]}
  yq -i "del(.${env_key})" $LCT_ENV_FILE
  unset -v $env_key
  eval "$(send_environment)"

}

# :command.function
lct_env_list_command() {

  # src/commands/env/list.sh
  env_key=${args[--key]:-""}
  if [ -z "$env_key" ]; then
    yq -o=shell $LCT_ENV_FILE
  else
    echo "$env_key=$(yq ".$env_key" $LCT_ENV_FILE)"
  fi

}

# :command.function
lct_plugin_create_command() {

  # src/commands/plugin/create.sh
  plugin_name=${args[plugin]}
  PLUGINS_DIR=${LCT_SOFTWARE_DIR}/plugins

  echo "Creating plugin directory for '${plugin_name}'"
  mkdir -p "${PLUGINS_DIR}/${plugin_name}"

  echo "Creating initial files for plugin '${plugin_name}'"
  cat <<EOF >"${PLUGINS_DIR}/${plugin_name}/README.md"
# ${plugin_name} Plugin for LCT
#
# Describe the purpose and functionality of the plugin here.
Install the ${plugin_name} plugin and configure it as needed.
EOF
  cat <<EOF >"${PLUGINS_DIR}/${plugin_name}/main.sh"
# ${plugin_name} Plugin Main Script
# Add your plugin logic here.
EOF
  cat <<EOF >"${PLUGINS_DIR}/${plugin_name}/config.yaml"
# ${plugin_name} Plugin Configuration
# Add your plugin configuration options here.
name: ${plugin_name}
version: 0.1.0
filename: main.sh
EOF
  echo "✅ Plugin '${plugin_name}' created successfully in '${PLUGINS_DIR}/${plugin_name}'"

}

# :command.function
lct_plugin_publish_command() {

  # src/commands/plugin/publish.sh
  plugin_name=${args[plugin]}
  PLUGINS_DIR=${LCT_SOFTWARE_DIR}/plugins
  PLUGIN_DIR="${PLUGINS_DIR}/${plugin_name}"
  PLUGIN_CONFIG_FILE="${PLUGIN_DIR}/config.yaml"
  PLUGIN_VERSION=$(yq '.version' "$PLUGIN_CONFIG_FILE")
  PLUGIN_FILENAME=$(yq '.filename' "$PLUGIN_CONFIG_FILE")
  TMP_DIR=$(mktemp -d)

  trap 'rm -rf "$TMP_DIR"' EXIT

  mkdir -p "$TMP_DIR/$plugin_name/src"
  mkdir -p "$TMP_DIR/$plugin_name/target"

  git clone -q "$REGISTRY" "$TMP_DIR/registry"

  echo "Packaging plugin '${plugin_name}' version '${PLUGIN_VERSION}'"
  cp -r "$PLUGIN_DIR/$PLUGIN_FILENAME" "$TMP_DIR/$plugin_name/src/"
  PLUGIN_DESCRIPTION=$(cat $PLUGIN_DIR/README.md | sed 's/^/  /')

  cat <<EOF >"${TMP_DIR}/${plugin_name}/src/bashly.yml"
name: ${plugin_name}
version: ${PLUGIN_VERSION}
help: |
  ${plugin_name} Plugin for LCT
${PLUGIN_DESCRIPTION}
filename: ${PLUGIN_FILENAME}
EOF

  cat <<EOF >"${TMP_DIR}/${plugin_name}/settings.yml"
target_dir: target
partials_extension: sh
strict: set -Eeuo pipefail
tab_indent: false
word_wrap: 80
formatter: internal
EOF

  cat <<EOF >"${TMP_DIR}/${plugin_name}/src/header.sh"
#!/usr/bin/env bash
EOF

  cd "$TMP_DIR/$plugin_name"

  echo "Validating Plugin Bashly configuration"
  bashly validate
  echo "Generating Plugin Bashly files"
  bashly generate
  mv target/${plugin_name} target/${plugin_name}-${PLUGIN_VERSION}
  echo "Packaging Plugin into tar.xz archive"
  tar -cJf "$TMP_DIR/registry/plugins/${plugin_name}-${PLUGIN_VERSION}.tar.xz" -C "$TMP_DIR/$plugin_name/target" "${plugin_name}-${PLUGIN_VERSION}"
  echo "Publishing Plugin to registry"
  # TODO: change to publishing to a central repo
  cd "$TMP_DIR/registry"
  git add .
  git commit -m "Publish plugin ${plugin_name} version ${PLUGIN_VERSION}" || echo "No changes to commit"
  git push origin main || echo "No remote repository configured, skipping push"
  echo "✅ Plugin '${plugin_name}' version '${PLUGIN_VERSION}' published successfully"

}

# :command.function
lct_plugin_install_command() {

  # src/commands/plugin/install.sh
  echo "# This file is located at 'src/commands/plugin/install.sh'."
  echo "# It contains the implementation for the 'lct plugin install' command."
  echo "# The code you write here will be wrapped by a function named 'lct_plugin_install_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
lct_plugin_remove_command() {

  # src/commands/plugin/remove.sh
  echo "# This file is located at 'src/commands/plugin/remove.sh'."
  echo "# It contains the implementation for the 'lct plugin remove' command."
  echo "# The code you write here will be wrapped by a function named 'lct_plugin_remove_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
lct_plugin_list_command() {

  # src/commands/plugin/list.sh
  echo "# This file is located at 'src/commands/plugin/list.sh'."
  echo "# It contains the implementation for the 'lct plugin list' command."
  echo "# The code you write here will be wrapped by a function named 'lct_plugin_list_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
lct_bootstrap_command() {

  # src/commands/bootstrap.sh
  CONFIG_VERSION=${args[--config]:-""}
  FORCE=${args[--force]:-0}
  TMP_DIR=$(mktemp -d)

  trap 'rm -rf "$TMP_DIR"' EXIT

  if [[ ! -z $CONFIG_VERSION ]]; then
    LATEST_LCT_VERSION="$CONFIG_VERSION"
  fi

  LATEST_LCT_VERSION_DIR="$TMP_DIR/$LATEST_LCT_VERSION"

  echo "Starting Bootstrap Process"

  echo "Decompressing latest configuration version: $LATEST_LCT_VERSION"
  tar -xJf "$LCT_VERSIONS_DIR/$LATEST_LCT_VERSION.tar.xz" -C "$TMP_DIR"
  echo "✅ Decompression complete"

  if [ -f "$LCT_BREW_FILE" ] && [ $FORCE == 0 ]; then
    echo "Using existing Brewfile at $LCT_BREW_FILE"
  else
    echo "No Brewfile found, using the one from the latest config version"
    cp "$LATEST_LCT_VERSION_DIR/Brewfile" "$LCT_BREW_FILE"
  fi

  if [ -f "$LCT_CONFIG_FILE" ] && [ $FORCE == 0 ]; then
    echo "Using existing config.yaml at $LCT_CONFIG_FILE"
  else
    echo "No config.yaml found, using the one from the latest config version"
    cp "$LATEST_LCT_VERSION_DIR/config.yaml" "$LCT_CONFIG_FILE"
  fi

  echo "Installing homebrew dependencies"
  brew bundle --file "$LCT_BREW_FILE"
  echo "✅ homebrew dependencies succesfully installed"

  if [ -d "$SOFTWARE_DIR" ]; then
    echo " $SOFTWARE_DIR already exists"
  else
    echo " Creating $SOFTWARE_DIR"
    mkdir -p $SOFTWARE_DIR
  fi

  echo "Applying library configs"

  for lib in "${CONFIGS[@]}"; do
    if [ -d "$CONFIG_DIR/$lib" ]; then
      echo "$lib config already exists"
    else
      echo "Applying $lib config"
      cp -r "$LATEST_LCT_VERSION_DIR/$lib" "$CONFIG_DIR/"
    fi
  done

  echo "✅ Configs successfully copied"

  total_plugins=${#PLUGINS[@]}
  loaded=0

  for key in "${!PLUGINS[@]}"; do
    version="${PLUGINS[$key]}"
    plugin=${key}
    if [ -f "$LCT_PLUGINS_DIR/$plugin-$version" ]; then
      echo "✅ $plugin already installed"
    else
      echo "installing $plugin"
      [[ -d $TMP_DIR/registry ]] || git clone -q $REGISTRY $TMP_DIR/registry

      # TODO: change to downloading from a central repo
      tar -xJf "$TMP_DIR/registry/plugins/$plugin-$version.tar.xz" -C "$LCT_PLUGINS_DIR/"
    fi
    eval "$LCT_PLUGINS_DIR/$plugin-$version"
  done
  # ##################################################

  echo "✅ Bootstrap complete"
  echo "Feel free to add  the following to your zshrc file"
  echo 'eval "$(lct setup)"'

}

# :command.function
lct_completions_command() {

  # src/commands/completions.sh
  send_completions

}

# :command.function
lct_config_command() {

  # src/commands/config.sh
  lib_name="${args[lib_name]:-lct}"

  # List of possible extensions
  exts="yaml json kdl toml ini env sh fish ps1 conf cfg xml properties plist yml"

  # Construct array of possible config paths
  candidates=()
  for ext in $exts; do
    candidates+=("$CONFIG_DIR/$lib_name/config.$ext")
    candidates+=("$CONFIG_DIR/$lib_name/$lib_name.$ext")
    candidates+=("$CONFIG_DIR/$lib_name.$ext") # Sometimes config is at ~/.config/libname.ext
  done

  # Find the first existing config file
  for path in "${candidates[@]}"; do
    if [ -f "$path" ]; then
      eval "$EDITOR \"$path\""
      exit 0
    fi
  done

  echo "No config file found for $lib_name in $CONFIG_DIR"

}

# :command.function
lct_setup_command() {

  # src/commands/setup.sh
  echo $"autoload -Uz +X bashcompinit && bashcompinit"
  printf '\n\n'
  send_environment
  printf '\n\n'
  send_completions
  printf '\n\n'
  zoxide init zsh
  printf '\n\n'
  zellij setup --generate-auto-start zsh

}

# :command.function
lct_gather_command() {

  # src/commands/gather.sh
  latest_version=$(yq '.latest' "$LCT_VERSIONS_FILE")
  this_version=$(date +%Y.%m.%d)

  FORCE=${args[--force]:-0}
  VERSION_DIR="$LCT_VERSIONS_DIR/$this_version"
  LCT_FILES=("$LCT_BREW_FILE" "$LCT_CONFIG_FILE")

  if [ "$this_version" == "$latest_version" ]; then
    if [[ $FORCE -eq 1 ]]; then
      echo "⚠ Forcing config gather despite being up to date"
    else
      echo "✅ Configs are already up to date"
      exit 0
    fi
  fi

  echo "Gathering configs for new version: $this_version"
  mkdir -p "$VERSION_DIR"
  mkdir -p "$VERSION_DIR/config"
  mkdir -p "$VERSION_DIR/dotfiles"
  mkdir -p "$VERSION_DIR/lazyvim"

  echo "Gathering LCT files"
  for file in "${LCT_FILES[@]}"; do
    echo "Copying $(basename "$file")"
    cp -r "$file" "$VERSION_DIR/"
  done

  echo "Gather library configs"

  for lib in "${CONFIGS[@]}"; do
    echo "Copying $lib config"
    cp -r "$CONFIG_DIR/$lib" "$VERSION_DIR/config/"
  done

  echo "✅ Configs successfully gathered"

  echo "Gathering dotfiles"

  for file in "${DOTFILES[@]}"; do
    echo "Copying $file"
    cp -r "$HOME/$file" "$VERSION_DIR/dotfiles/"
  done

  echo "✅ Dotfiles successfully gathered"

  echo "Gathering other files"
  for key in "${!OTHERFILES[@]}"; do
    src_file="$HOME/${OTHERFILES[$key]}"
    dest_file="$VERSION_DIR/$key"
    dest_dir=$(dirname "$dest_file")
    echo "Copying $src_file to $dest_file"
    mkdir -p "$dest_dir"
    cp -r "$src_file" "$dest_file"
  done

  echo "✅ Other files successfully gathered"

  echo "Compressing gathered configuration"
  tar -cJf "$LCT_VERSIONS_DIR/$this_version.tar.xz" -C "$LCT_VERSIONS_DIR" "$this_version"
  rm -rf "$VERSION_DIR"
  echo "✅ Successfully compressed configuration"

  # Update latest version in lct.yaml
  yq -i ".latest = \"$this_version\"" "$LCT_VERSIONS_FILE"

  git -C "$LCT_VERSIONS_DIR" add .
  git -C "$LCT_VERSIONS_DIR" commit -m "Gather configs for version $this_version" || echo "No changes to commit"
  git -C "$LCT_VERSIONS_DIR" push origin main || echo "No remote repository configured, skipping push"
  echo "✅ Config gather for version $this_version completed successfully"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lct_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    lib)
      action="lib"
      shift
      lct_lib_parse_requirements "$@"
      shift $#
      ;;

    env | e)
      action="env"
      shift
      lct_env_parse_requirements "$@"
      shift $#
      ;;

    plugin)
      action="plugin"
      shift
      lct_plugin_parse_requirements "$@"
      shift $#
      ;;

    bootstrap | b)
      action="bootstrap"
      shift
      lct_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      lct_completions_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      lct_config_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      lct_setup_parse_requirements "$@"
      shift $#
      ;;

    gather | g)
      action="gather"
      shift
      lct_gather_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    install)
      action="install"
      shift
      lct_lib_install_parse_requirements "$@"
      shift $#
      ;;

    add)
      action="add"
      shift
      lct_lib_add_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      lct_lib_remove_parse_requirements "$@"
      shift $#
      ;;

    dump)
      action="dump"
      shift
      lct_lib_dump_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      lct_lib_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_lib_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_install_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_add_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['library']+x} ]]; then
          args['library']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['library']+x} ]]; then
    printf "missing required argument: LIBRARY\nusage: lct lib add LIBRARY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_lib_remove_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['library']+x} ]]; then
          args['library']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['library']+x} ]]; then
    printf "missing required argument: LIBRARY\nusage: lct lib remove LIBRARY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_lib_dump_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_dump_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib dump"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_lib_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_lib_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lib list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --type | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--type']="$2"
          shift
          shift
        else
          printf "%s\n" "--type requires an argument: --type, -t TYPE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_env_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      lct_env_set_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      lct_env_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      lct_env_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_env_set_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['key']+x} ]]; then
          args['key']=$1
          shift
        # :argument.case
        elif [[ -z ${args['value']+x} ]]; then
          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: lct env set KEY VALUE\n" >&2

    exit 1
  fi

  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: lct env set KEY VALUE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_env_unset_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['key']+x} ]]; then
          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: lct env unset KEY\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_env_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_env_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --key | -k)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key, -k KEY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_plugin_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      lct_plugin_create_parse_requirements "$@"
      shift $#
      ;;

    publish)
      action="publish"
      shift
      lct_plugin_publish_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      lct_plugin_install_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      lct_plugin_remove_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      lct_plugin_list_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lct_plugin_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_plugin_create_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="plugin create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plugin']+x} ]]; then
          args['plugin']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['plugin']+x} ]]; then
    printf "missing required argument: PLUGIN\nusage: lct plugin create PLUGIN\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_plugin_publish_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_publish_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="plugin publish"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plugin']+x} ]]; then
          args['plugin']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['plugin']+x} ]]; then
    printf "missing required argument: PLUGIN\nusage: lct plugin publish PLUGIN\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_plugin_install_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="plugin install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plugin']+x} ]]; then
          args['plugin']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['plugin']+x} ]]; then
    printf "missing required argument: PLUGIN\nusage: lct plugin install PLUGIN\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_plugin_remove_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="plugin remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plugin']+x} ]]; then
          args['plugin']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['plugin']+x} ]]; then
    printf "missing required argument: PLUGIN\nusage: lct plugin remove PLUGIN\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
lct_plugin_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_plugin_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="plugin list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_bootstrap_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_completions_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_config_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['lib_name']+x} ]]; then
          args['lib_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
lct_setup_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lct_gather_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        lct_gather_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gather"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.4.0"
  set -Eeuo pipefail

  # src/initialize.sh
  # Function to handle errors
  error_handler() {
    local exit_code=$? # Capture the exit code of the failed command
    echo "❌ ERROR: Command failed with exit code $exit_code on line $LINENO" >&2
    echo "❌ Failing command: $BASH_COMMAND" >&2
    echo "❌ Local bootstrap failed"
    exit $exit_code # Exit the script with the original error code
  }

  # Expects:
  #   REMOTE_CONFIG_REPO   e.g. https://github.com/org/repo.git  (or git@github.com:org/repo.git)
  #   LCT_VERSIONS_DIR     path to an existing git working tree
  set_origin_remote() {
    : "${REMOTE_CONFIG_REPO:?REMOTE_CONFIG_REPO is required}"
    : "${LCT_VERSIONS_DIR:?LCT_VERSIONS_DIR is required}"

    if [[ ! -d "$LCT_VERSIONS_DIR/.git" ]]; then
      echo "Not a git repo: $LCT_VERSIONS_DIR" >&2
      return 1
    fi

    local current
    current="$(git -C "$LCT_VERSIONS_DIR" remote get-url origin 2>/dev/null || true)"

    if [[ -z "$current" ]]; then
      git -C "$LCT_VERSIONS_DIR" remote add origin "$REMOTE_CONFIG_REPO" &>/dev/null
    elif [[ "$current" != "$REMOTE_CONFIG_REPO" ]]; then
      git -C "$LCT_VERSIONS_DIR" remote set-url origin "$REMOTE_CONFIG_REPO" &>/dev/null
    fi
  }

  detect_directories() {
    if [ -z "${SOFTWARE_DIR+x}" ]; then
      SOFTWARE_DIR="$HOME/software"
    fi

    if [ -z "${CONFIG_DIR+x}" ]; then
      CONFIG_DIR="$HOME/.config"
    fi

    if [ -z "${SHARE_DIR+x}" ]; then
      SHARE_DIR="$HOME/.local/share"
    fi

    if [ -z "${STATE_DIR+x}" ]; then
      STATE_DIR="$HOME/.local/state"
    fi

    if [ -z "${CACHE_DIR+x}" ]; then
      CACHE_DIR="$HOME/.cache"
    fi

    LCT_SOFTWARE_DIR="${SOFTWARE_DIR}/lct"
    LCT_SHARE_DIR="${SHARE_DIR}/lct"
    LCT_CONFIG_DIR="${CONFIG_DIR}/lct"
    LCT_CACHE_DIR="${CACHE_DIR}/lct"
    LCT_ENV_FILE="${LCT_SHARE_DIR}/env.yaml"
    LCT_CONFIG_FILE="${LCT_CONFIG_DIR}/config.yaml"
    LCT_VERSIONS_DIR="${LCT_SHARE_DIR}/config_versions"
    LCT_VERSIONS_FILE="${LCT_VERSIONS_DIR}/lct.yaml"
    LCT_BREW_FILE="${LCT_SHARE_DIR}/Brewfile"
    LCT_PLUGINS_DIR="${LCT_CACHE_DIR}/plugins"
  }

  setup_directories() {
    detect_directories

    [[ -d "${LCT_SOFTWARE_DIR}" ]] || mkdir -p "${LCT_SOFTWARE_DIR}"
    [[ -d "${LCT_SHARE_DIR}" ]] || mkdir -p "${LCT_SHARE_DIR}"
    [[ -d "${LCT_CONFIG_DIR}" ]] || mkdir -p "${LCT_CONFIG_DIR}"
    [[ -d "${LCT_VERSIONS_DIR}" ]] || mkdir -p "${LCT_VERSIONS_DIR}"
    [[ -f "${LCT_ENV_FILE}" ]] || touch "${LCT_ENV_FILE}"
    [[ -f "${LCT_CONFIG_FILE}" ]] || touch "${LCT_CONFIG_FILE}"
    [[ -f "${LCT_VERSIONS_FILE}" ]] || touch "${LCT_VERSIONS_FILE}"
    [[ -d "$LCT_VERSIONS_DIR/.git" ]] || git init "$LCT_VERSIONS_DIR"
    [[ -f "${LCT_BREW_FILE}" ]] || touch "${LCT_BREW_FILE}"
    [[ -d "${LCT_PLUGINS_DIR}" ]] || mkdir -p "${LCT_PLUGINS_DIR}"
  }

  load_configuration() {
    # TODO: change to a central registry
    # Load LCT configuration
    if [[ -f "${LCT_CONFIG_FILE}" ]]; then
      REMOTE_CONFIG_REPO=$(yq '.remote' ${LCT_CONFIG_FILE})
      CONFIGS=($(yq -o=csv '.configs[]' ${LCT_CONFIG_FILE}))
      DOTFILES=($(yq -o=csv '.dotfiles[]' ${LCT_CONFIG_FILE}))
      declare -gA OTHERFILES
      eval "OTHERFILES=($(yq -r '.other | to_entries | .[] | "[\(.key)]=\"\(.value)\""' ${LCT_CONFIG_FILE} | paste -sd' ' -))"
      declare -gA PLUGINS
      eval "PLUGINS=($(yq -r '.plugins | to_entries | .[] | "[\(.key)]=\"\(.value)\""' ${LCT_CONFIG_FILE} | paste -sd' ' -))"
      REGISTRY=$(yq '.registry // "git@github.com:frostme/local-plugins.git"' ${LCT_CONFIG_FILE})
    fi
  }

  load_env() {
    # Load LCT environment variables
    if [[ -f "${LCT_ENV_FILE}" ]]; then
      eval "$(yq -o=shell '.' ${LCT_ENV_FILE})"
    fi

    if [ -z "${LATEST_LCT_VERSION+x}" ]; then
      LATEST_LCT_VERSION=$(yq '.latest' "$LCT_VERSIONS_FILE")
      LATEST_LCT_VERSION_DIR="$LCT_VERSIONS_DIR/$LATEST_LCT_VERSION"
    fi

    if [ $REMOTE_CONFIG_REPO != "null" ]; then
      set_origin_remote
    fi
  }

  trap 'error_handler' ERR
  setup_directories
  load_configuration
  load_env

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "lib") lct_lib_command ;;
    "lib install") lct_lib_install_command ;;
    "lib add") lct_lib_add_command ;;
    "lib remove") lct_lib_remove_command ;;
    "lib dump") lct_lib_dump_command ;;
    "lib list") lct_lib_list_command ;;
    "env") lct_env_command ;;
    "env set") lct_env_set_command ;;
    "env unset") lct_env_unset_command ;;
    "env list") lct_env_list_command ;;
    "plugin") lct_plugin_command ;;
    "plugin create") lct_plugin_create_command ;;
    "plugin publish") lct_plugin_publish_command ;;
    "plugin install") lct_plugin_install_command ;;
    "plugin remove") lct_plugin_remove_command ;;
    "plugin list") lct_plugin_list_command ;;
    "bootstrap") lct_bootstrap_command ;;
    "completions") lct_completions_command ;;
    "config") lct_config_command ;;
    "setup") lct_setup_command ;;
    "gather") lct_gather_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
