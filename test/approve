#!/usr/bin/env bash
tmpdir="$(mktemp -d)"
tmpdir_escaped=$(printf '%s\n' "$tmpdir" | sed 's/[]\/$*.^|[]/\\&/g')
cli="$(cd "$(dirname "$0")/.." && pwd)/target/build/lct"
semver_tool="$(cd "$(dirname "$0")/.." && pwd)/lct_modules/bin/semver"
mkdir -p "$tmpdir/.config" "$tmpdir/.local/share" "$tmpdir/.local/state" "$tmpdir/.cache"
export HOME="$tmpdir"
export EDITOR="nvim"
export CONFIG_DIR="$tmpdir/.config"
export SHARE_DIR="$tmpdir/.local/share"
export STATE_DIR="$tmpdir/.local/state"
export CACHE_DIR="$tmpdir/.cache"
export LCT_GITHUB_BASE="file://${tmpdir}/mock-github"
export LCT_VERSION=$("${cli}" --version | awk '{print $NF}')
export UPDATE_VERSION=$("${semver_tool}" bump minor "$LCT_VERSION")

stubdir="$tmpdir/bin"
mkdir -p "$stubdir"
export PATH="$stubdir:/home/runner/go/bin:$PATH"

cat >"$stubdir/brew" <<'EOF'
#!/usr/bin/env bash
if [[ "${FAIL_BREW:-}" == "1" ]]; then
  echo "brew failed" >&2
  exit 1
fi
cmd="$1"
shift || true
if [[ "$cmd" == "bundle" && "${1:-}" == "dump" ]]; then
  output_file=""
  while (($#)); do
    case "$1" in
    --file=*)
      output_file="${1#--file=}"
      ;;
    --file)
      shift || true
      output_file="${1:-}"
      ;;
    esac
    shift || true
  done
  if [[ -n "$output_file" ]]; then
    cat >"$output_file" <<'BUNDLE'
brew "bat"
cask "docker"
BUNDLE
  fi
  exit 0
fi
printf "brew %s %s\n" "$cmd" "$*"
EOF
chmod +x "$stubdir/brew"

cat >"$stubdir/mise" <<'EOF'
#!/usr/bin/env bash
if [[ "${FAIL_MISE:-}" == "1" ]]; then
  echo "mise failed" >&2
  exit 1
fi
cmd="$1"
shift || true
printf "mise %s %s\n" "$cmd" "$*"
EOF
chmod +x "$stubdir/mise"

for tool in apt apt-get dnf yum zypper pacman paru yay nix-env flox winget scoop pkg; do
  cat >"$stubdir/$tool" <<'EOF'
#!/usr/bin/env bash
echo "$(basename "$0") $*"
EOF
  chmod +x "$stubdir/$tool"
done

cat >"$stubdir/curl" <<'EOF'
#!/usr/bin/env bash
if [[ "${FAIL_CURL:-}" == "1" ]]; then
  echo "curl failed" >&2
  exit 1
fi
if [[ "$*" == *"/repos/frostme/lct/releases/latest"* ]]; then
  printf '{"tag_name":"%s"}
' "${MOCK_LCT_LATEST_TAG:-v$UPDATE_VERSION}"
  exit 0
fi
if [[ "$*" == *"https://frostme.github.io/lct/install.sh"* ]]; then
  cat <<'SCRIPT'
#!/usr/bin/env bash
echo "installer ran"
SCRIPT
  exit 0
fi
echo "curl $*"
EOF
chmod +x "$stubdir/curl"

cat >"$stubdir/gum" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

cmd="${1:-}"
shift || true

case "$cmd" in
  spin)
    # Execute the command after "--" to mimic gum spinner behavior in tests.
    while (($#)); do
      if [[ "$1" == "--" ]]; then
        shift
        break
      fi
      shift
    done
    if (($#)); then
      "$@"
    fi
    ;;
  style)
    text="${*: -1}"
    if printf '%s\n' "$*" | grep -q -- '--border'; then
      # Minimal boxed output for the specific style used in gum_title.
      padding_left=1
      padding_right=1
      text_length=${#text}
      inner_width=$((text_length + padding_left + padding_right))
      top_bottom=""
      for ((i = 0; i < inner_width; i++)); do
        top_bottom+="─"
      done
      printf '┌%s┐\n' "$top_bottom"
      printf '│%*s%s%*s│\n' "$padding_left" '' "$text" "$padding_right" ''
      printf '└%s┘\n' "$top_bottom"
      printf '%*s\n' "$((inner_width + 2))" ''
    else
      printf '%s\n' "$text"
    fi
    ;;
  confirm)
    prompt="${*: -1}"
    printf '%s\n' "$prompt"
    if [[ "${GUM_CONFIRM_RESULT:-yes}" == "no" ]]; then
      exit 1
    fi
    ;;
  *)
    exit 0
    ;;
esac
EOF
chmod +x "$stubdir/gum"

cat >"$stubdir/asdf" <<'EOF'
#!/usr/bin/env bash
echo "asdf $*"
EOF
chmod +x "$stubdir/asdf"

for tool in npm pnpm yarn bun cargo cargo-binstall pip uv gem go composer mvn gradle dotnet; do
  cat >"$stubdir/$tool" <<'EOF'
#!/usr/bin/env bash
echo "$(basename "$0") $*"
EOF
  chmod +x "$stubdir/$tool"
done

trap 'rm -rf "$tmpdir"' EXIT

source test/approvals.bash

cd ./test || exit
export APPROVALS_DIR="$(pwd)/approvals"

describe "help text"
approve "${cli} --help | sed 's/${tmpdir_escaped}/~/g'" "help_text"

describe "env command"
it "sets and lists environment variables"
approve "${cli} env set SAMPLE_KEY sample-value" "env_set_sample"
approve "${cli} env list" "env_list"

describe "alias and reload commands"
it "adds an alias"
approve "${cli} alias add ll 'ls -la'" "alias_add"
it "reloads environment variables and aliases"
approve "${cli} reload" "reload"
it "removes an alias"
approve "${cli} alias remove ll" "alias_remove"

describe "dotfiles command"
it "adds a dotfile"
approve "${cli} dotfiles add \"$tmpdir/.zshrc\"" "dotfiles_add"
approve "${cli} dotfiles list" "dotfiles_list_after_add"
it "removes a dotfile"
approve "${cli} dotfiles remove \"$tmpdir/.zshrc\"" "dotfiles_remove"
approve "${cli} dotfiles list" "dotfiles_list_after_remove"

describe "configs command"
it "adds a config directory"
approve "${cli} configs add \"$tmpdir/.config/alacritty\"" "configs_add"
approve "${cli} configs list" "configs_list_after_add"
it "removes a config directory"
approve "${cli} configs remove \"$tmpdir/.config/alacritty\"" "configs_remove"
approve "${cli} configs list" "configs_list_after_remove"

describe "install command"
mock_repo_root="$tmpdir/mock-github/example/demo"
mkdir -p "$mock_repo_root"
git -C "$mock_repo_root" init -q
git -C "$mock_repo_root" config user.email "test@example.com"
git -C "$mock_repo_root" config user.name "Test User"
cat >"$mock_repo_root/demo" <<'EOF'
#!/usr/bin/env bash
echo "demo module"
EOF
chmod +x "$mock_repo_root/demo"
git -C "$mock_repo_root" add demo
git -C "$mock_repo_root" commit -q -m "initial"
git -C "$mock_repo_root" tag v1.0.0
cat >"$mock_repo_root/demo" <<'EOF'
#!/usr/bin/env bash
echo "demo module v1.1"
EOF
git -C "$mock_repo_root" add demo
git -C "$mock_repo_root" commit -q -m "second"
git -C "$mock_repo_root" tag v1.1.0
approve "${cli} install -g example/demo" "install_module"
approve "${cli} install -g example/demo" "install_module_idempotent"
approve "cat $tmpdir/.local/share/lct/LCTFile" "install_module_global_lctfile"

semver_repo_root="$tmpdir/mock-github/fsaintjacques/semver-tool"
mkdir -p "$semver_repo_root/src" "$semver_repo_root/test"
git -C "$semver_repo_root" init -q
git -C "$semver_repo_root" config user.email "test@example.com"
git -C "$semver_repo_root" config user.name "Test User"
cat >"$semver_repo_root/src/semver" <<'EOF'
#!/usr/bin/env bash
echo "semver"
EOF
chmod +x "$semver_repo_root/src/semver"
cat >"$semver_repo_root/test/documentation-test" <<'EOF'
#!/usr/bin/env bash
echo "docs test"
EOF
chmod +x "$semver_repo_root/test/documentation-test"
git -C "$semver_repo_root" add src/semver test/documentation-test
git -C "$semver_repo_root" commit -q -m "initial"
approve "${cli} install -g fsaintjacques/semver-tool" "install_module_semver"

minifier_repo_root="$tmpdir/mock-github/Zuzzuc/Bash-minifier"
mkdir -p "$minifier_repo_root/test"
git -C "$minifier_repo_root" init -q
git -C "$minifier_repo_root" config user.email "test@example.com"
git -C "$minifier_repo_root" config user.name "Test User"
cat >"$minifier_repo_root/Minifier.sh" <<'EOF'
#!/usr/bin/env bash
echo "minifier"
EOF
chmod +x "$minifier_repo_root/Minifier.sh"
cat >"$minifier_repo_root/test/test.sh" <<'EOF'
#!/usr/bin/env bash
echo "test"
EOF
chmod +x "$minifier_repo_root/test/test.sh"
git -C "$minifier_repo_root" add Minifier.sh test/test.sh
git -C "$minifier_repo_root" commit -q -m "initial"
approve "${cli} install -g Zuzzuc/Bash-minifier" "install_module_minifier"

ambiguous_repo_root="$tmpdir/mock-github/example/ambiguous"
mkdir -p "$ambiguous_repo_root/docs" "$ambiguous_repo_root/test"
git -C "$ambiguous_repo_root" init -q
git -C "$ambiguous_repo_root" config user.email "test@example.com"
git -C "$ambiguous_repo_root" config user.name "Test User"
cat >"$ambiguous_repo_root/docs/run.sh" <<'EOF'
#!/usr/bin/env bash
echo "docs"
EOF
chmod +x "$ambiguous_repo_root/docs/run.sh"
cat >"$ambiguous_repo_root/test/helper.sh" <<'EOF'
#!/usr/bin/env bash
echo "test"
EOF
chmod +x "$ambiguous_repo_root/test/helper.sh"
git -C "$ambiguous_repo_root" add docs/run.sh test/helper.sh
git -C "$ambiguous_repo_root" commit -q -m "initial"
approve "${cli} install -g example/ambiguous" "install_module_ambiguous"

make_repo_root="$tmpdir/mock-github/example/makepkg"
mkdir -p "$make_repo_root"
git -C "$make_repo_root" init -q
git -C "$make_repo_root" config user.email "test@example.com"
git -C "$make_repo_root" config user.name "Test User"
cat >"$make_repo_root/main.sh" <<'EOF'
#!/usr/bin/env bash
echo "make module"
EOF
chmod +x "$make_repo_root/main.sh"
cat >"$make_repo_root/Makefile" <<'EOF'
all:
	@mkdir -p bin
	@cp main.sh bin/make-tool

install: all
	@mkdir -p $(PREFIX)/bin
	@cp bin/make-tool $(PREFIX)/bin/make-tool
EOF
git -C "$make_repo_root" add main.sh Makefile
git -C "$make_repo_root" commit -q -m "initial"
project_make="$tmpdir/project-make"
mkdir -p "$project_make"
touch "$project_make/LCTFile"
pushd "$project_make" >/dev/null
approve "${cli} install example/makepkg" "install_module_make"
popd >/dev/null

manifest_repo_root="$tmpdir/mock-github/whoaa512/hyperfine"
mkdir -p "$manifest_repo_root"
git -C "$manifest_repo_root" init -q
git -C "$manifest_repo_root" config user.email "test@example.com"
git -C "$manifest_repo_root" config user.name "Test User"
cat >"$manifest_repo_root/package.json" <<'EOF'
{
  "name": "hyperfine",
  "version": "1.0.0"
}
EOF
git -C "$manifest_repo_root" add package.json
git -C "$manifest_repo_root" commit -q -m "initial"
manifest_project="$tmpdir/project-manifest"
mkdir -p "$manifest_project"
touch "$manifest_project/LCTFile"
pushd "$manifest_project" >/dev/null
approve "${cli} install whoaa512/hyperfine" "install_module_manifest_node"
approve "${cli} remove whoaa512/hyperfine" "remove_module_manifest_node"
popd >/dev/null

approve "${cli} install -g" "install_without_modules"
describe "install via LCTFile"
project_dir="$tmpdir/project"
mkdir -p "$project_dir"
cat >"$project_dir/LCTFile" <<'EOF'
example/demo = 'v1.0.0'
example/demo
EOF
pushd "$project_dir" >/dev/null
approve "${cli} install" "install_from_lctfile"
approve "${cli} install" "install_from_lctfile_idempotent"
approve "${cli} install example/demo" "install_module_local"
approve "cat LCTFile" "install_module_local_lctfile"
popd >/dev/null

describe "remove command"
approve "(cd $project_dir && ${cli} remove example/demo)" "remove_module_local"
approve "cat $project_dir/LCTFile" "remove_module_local_lctfile"
approve "(cd $project_dir && ${cli} remove example/demo)" "remove_module_local_idempotent"
approve "${cli} remove -g example/demo" "remove_module_global"
approve "cat $tmpdir/.local/share/lct/LCTFile" "remove_module_global_lctfile"
approve "${cli} remove -g example/demo" "remove_module_global_idempotent"

describe "prune command"
mkdir -p "$tmpdir/.cache/lct/plugins/acme/tool"
it "lists cache directories in dry run mode"
approve "${cli} prune --cache --dry | sed 's/${tmpdir_escaped}/~/g'" "prune_cache_dry_run_lists_cache_dirs"

describe "gather command"
mkdir -p "$tmpdir/.config/nvim" "$tmpdir/.config/lazygit" "$tmpdir/.local/share" "$tmpdir/work"
touch "$tmpdir/.config/nvim/init.lua"
touch "$tmpdir/.config/lazygit/config.yml"
touch "$tmpdir/.zshrc"
touch "$tmpdir/work/custom.conf"
cat >"$tmpdir/.config/lct/config.yaml" <<'EOF'
remote: null
configs:
  - nvim
  - lazygit
dotfiles:
  - .zshrc
other:
  work/custom.conf: work/custom.conf
plugins: []
modules: []
packageManager: brew
EOF
it "gathers configured files into the remote repository"
approve "GIT_AUTHOR_NAME=Test GIT_AUTHOR_EMAIL=test@example.com GIT_COMMITTER_NAME=Test GIT_COMMITTER_EMAIL=test@example.com ${cli} gather --force | sed -E 's/[0-9]{4}\-[0-9]{2}\-[0-9]{2}/<DATE>/g; s/T[0-9]{2}:[0-9]{2}:[0-9]{2}Z/<TIME>/g; s/${tmpdir_escaped}/~/g; s/[0-9]+ file(s)? changed.*/<GIT_COMMIT_SUMMARY>/g; s/[a-f0-9]{7}\.\.[a-f0-9]{7}/<GIT_RANGE>/g; s/\[main \(root-commit\) [a-f0-9]{7}\]/[main (root-commit) <GIT_HASH>]/g' | sed '/^ create mode /d'" "gather_force":

describe "gather command secret detection"
secret_home="$tmpdir/secret-home"
mkdir -p "$secret_home/.config/lct" "$secret_home/.local/share" "$secret_home/work"
cat >"$secret_home/.config/lct/config.yaml" <<'EOF'
remote: null
configs: []
dotfiles: []
other:
  work/claude.json: work/claude.json
plugins: []
modules: []
EOF
cat >"$secret_home/work/claude.json" <<'EOF'
{
  "api_key": "sk-test-123",
  "authorization": "Bearer secret",
  "name": "demo"
}
EOF
it "scrubs detected secrets when requested"
approve "HOME=$secret_home CONFIG_DIR=$secret_home/.config SHARE_DIR=$secret_home/.local/share STATE_DIR=$secret_home/.local/state CACHE_DIR=$secret_home/.cache LCT_GATHER_SECRET_ACTION=scrub GIT_AUTHOR_NAME=Test GIT_AUTHOR_EMAIL=test@example.com GIT_COMMITTER_NAME=Test GIT_COMMITTER_EMAIL=test@example.com ${cli} gather --force | sed -E 's/[0-9]{4}\-[0-9]{2}\-[0-9]{2}/<DATE>/g; s/T[0-9]{2}:[0-9]{2}:[0-9]{2}Z/<TIME>/g; s/${tmpdir_escaped}/~/g; s/[0-9]+ file(s)? changed.*/<GIT_COMMIT_SUMMARY>/g; s/[a-f0-9]{7}\.\.[a-f0-9]{7}/<GIT_RANGE>/g; s/\[main \(root-commit\) [a-f0-9]{7}\]/[main (root-commit) <GIT_HASH>]/g' | sed '/^ create mode /d'" "gather_scrub_secrets":
approve "if [[ ! -f $secret_home/.local/share/lct/remote/other/work/claude.json ]]; then echo 'secret file scrubbed'; else echo 'secret file still present'; fi" "gather_scrub_secrets_result"

describe "bootstrap command"
it "shows bootstrap help"
approve "${cli} bootstrap --help" "bootstrap_help"
it "bootstraps from gathered remote repository"
approve "${cli} bootstrap --force | sed -E 's/${tmpdir_escaped}/~/g'" "bootstrap_force"

describe "env command"
it "sets an environment variable"
approve "${cli} env set API_KEY 123" "env_set_api_key"
it "unsets an environment variable"
approve "${cli} env unset API_KEY" "env_unset_api_key"

describe "self-update command"
it "updates when a newer release is available"
approve "${cli} self-update | sed -E 's/${LCT_VERSION}/CURRENT_VERSION/g' | sed -E 's/${UPDATE_VERSION}/UPDATE_VERSION/g'" "self_update"
it "does nothing when already up to date"
approve "MOCK_LCT_LATEST_TAG=v${LCT_VERSION} ${cli} self-update | sed -E 's/${LCT_VERSION}/CURRENT_VERSION/g'" "self_update_already_latest"
it "shows an error when latest version lookup fails"
approve "FAIL_CURL=1 ${cli} self-update" "self_update_lookup_error"
